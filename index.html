<!doctype html>
<html lang="en">

<head>
	<meta charset="utf-8">

	<meta name="author" content="Tobias Becher">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

	<title>Global Game Changers</title>
	<link rel="icon" href="src/img/keynote.ico" type="image/x-icon">
	<!-- <link rel="stylesheet" href="dist/css/bootstrap.min.css"> -->
	<link rel="stylesheet" href="dist/reset.css">
	<link rel="stylesheet" href="dist/reveal.css">
	<link rel="stylesheet" href="dist/theme/custom.css">

	<!-- Theme used for syntax highlighted code -->
	<link rel="stylesheet" href="plugin/highlight/monokai.css">
</head>

<body>
	<div class="reveal">
		<div class="menubar">
			<div class='slide-number'></div>
		</div>
		<div class="slides">
			<!-- Dynamically loaded slides will appear here -->
		</div>
		<!-- <div class="horizontal-line"></div> -->
		<div class="citation-container"></div>
	</div>

	<!-- Additional JS -->
	<script src="dist/js/bibtex-bundle.js"></script>
	<script src="dist/js/d3-bundle.js"></script>
	<script src="dist/js/plotly-2.32.0.min.js" charset="utf-8"></script>
	<script src="dist/js/lottie-bundle.js"></script>


	<!-- Reveal.js and plugins -->
	<script src="dist/reveal.js"></script>
	<script src="plugin/zoom/zoom.js"></script>
	<script src="plugin/notes/notes.js"></script>
	<script src="plugin/search/search.js"></script>
	<script src="plugin/markdown/markdown.js"></script>
	<script src="plugin/highlight/highlight.js"></script>
	<script src="plugin/menu/menu.js"></script>
	<script src="plugin/simplemenu/simplemenu.js"></script>
	<script src="plugin/appearance/appearance.js"></script>
	<script src="plugin/counteract/counteract.js"></script>
	<script src="plugin/reveald3/reveald3.js"></script>
	<script src="plugin/math/math.js"></script>
	<script>
		async function loadSlides() {
			// Base names of your slides
			const slideNames = [
				"title",
				"data",
				"method",
				"explore",
				"podium",
				"final"
			];

			// Select the container for the slides
			const slideContainer = document.querySelector(".slides");

			// Loop through the list of slide names
			for (let name of slideNames) {
				const path = `slides/${name}.html`;
				const response = await fetch(path);
				const text = await response.text();
				slideContainer.innerHTML += text;
			}
		}

		async function initializeReveal() {
			await loadSlides(); // Ensure slides are loaded before initializing Reveal
			Reveal.initialize({
				width: "100%",
				height: "100%",
				margin: 0,
				center: false,
				controls: true,
				progress: false,
				hash: true,
				transition: "none",
				slideNumber: "c/t",
				menu: {
					titleSelector: '',
					useTextContentForMissingTitles: false,
					hideMissingTitles: true,
				},
				mathjax3: {
					mathjax: 'dist/js/mathjax-bundle.js',
					tex: {
						inlineMath: [['$', '$'], ['\\(', '\\)']],
					},
					options: {
						skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
					},
				},
				simplemenu: { flat: true, scale: 0.9, },
				// appearance: {
				// 	animatecsspath: {
				// 		link: 'https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.min.css',
				// 		compat: 'https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.compat.css',
				// 	}
				// },
				counteract: {
					counters: [
						{
							name: 'figcaption',
							selector: 'figcaption',
						},
						{
							name: 'table-caption',
							selector: '.table-caption',
						}
					]
				},
				plugins: [
					RevealZoom,
					RevealNotes,
					RevealSearch,
					RevealMarkdown,
					RevealHighlight,
					RevealMenu,
					Simplemenu,
					Appearance,
					CounterAct,
					Reveald3,
					RevealMath.MathJax3
				],
			}).then(function () {
				addCitationListeners();
				updateCitations();
			});
		}

		initializeReveal();
	</script>

	<script>
		// Citation handling
		function addCitationListeners() {
			Reveal.addEventListener('slidechanged', updateCitations);
			Reveal.addEventListener('fragmentshown', updateCitations);
			Reveal.addEventListener('fragmenthidden', updateCitations);
		}

		async function updateCitations(event) {
			const citationContainer = document.querySelector('.citation-container');
			if (!citationContainer) {
				console.error('Citation container not found');
				return;
			}
			citationContainer.innerHTML = '';

			const currentSlide = Reveal.getCurrentSlide();
			const citations = currentSlide.querySelectorAll('.citation[data-ref]');
			const visibleCitations = new Set();
			const refIndices = {};  // Object to store citation indices
			let citationIndex = 1;

			// Collect visible citations and assign numbers
			citations.forEach(citation => {
				if (citationIsVisible(citation)) {
					const ref = citation.dataset.ref;
					if (!refIndices[ref]) {  // If it's the first time this ref is seen on the slide
						refIndices[ref] = citationIndex++;
					}
					visibleCitations.add(ref);
					citation.textContent = `[${refIndices[ref]}]`;  // Use the stored index
					citation.dataset.citationNumber = refIndices[ref];
				}
			});

			// Process each visible citation
			for (const ref of visibleCitations) {
				const refText = await getReferenceText(ref);  // Await the promise to resolve
				const div = document.createElement('div');
				div.classList.add('citation-entry');

				const spanNumber = document.createElement('span');
				spanNumber.classList.add('citation-number');
				const citationNumber = refIndices[ref];  // Get the stored index from refIndices
				spanNumber.textContent = `[${citationNumber}] `; // Include the reference number

				const spanText = document.createElement('span');
				spanText.classList.add('citation-text');
				spanText.textContent = refText;

				div.appendChild(spanNumber);
				div.appendChild(spanText);
				citationContainer.appendChild(div);
			}
		}

		function citationIsVisible(citation) {
			const closestFragment = citation.closest('.fragment');
			return !closestFragment || closestFragment.classList.contains('visible');
		}

		async function loadBibliography() {
			try {
				const response = await fetch('./src/references.bib');
				const bibText = await response.text();
				return bibtex.parseBibFile(bibText);
			} catch (error) {
				console.error('Failed to load or parse bibliography:', error);
				return [];
			}
		}

		async function getReferenceText(ref) {
			const bibliography = await loadBibliography();
			const entry = bibliography.getEntry(ref);
			if (!entry) return 'Reference not found';

			// Determine if the entry is a bib object and has an AUTHOR field (simple check)
			if (entry.getField("AUTHOR")) {
				return getShortCitation(entry);  // Assuming bib object with author
			} else {
				return getNonBibCitation(entry); // Assuming non-bib object
			}
		}

		function getShortCitation(entry) {
			// Normalize and format author names
			const authorsRaw = bibtex.normalizeFieldValue(entry.getField("AUTHOR")).split(" and ");
			let authorsFormatted;
			if (authorsRaw.length > 2) {
				const firstAuthorParts = authorsRaw[0].split(", ");
				authorsFormatted = `${firstAuthorParts[1]} ${firstAuthorParts[0]}, et al.`;
			} else if (authorsRaw.length === 2) {
				const firstAuthorParts = authorsRaw[0].split(", ");
				const secondAuthorParts = authorsRaw[1].split(", ");
				authorsFormatted = `${firstAuthorParts[1]} ${firstAuthorParts[0]} and ${secondAuthorParts[1]} ${secondAuthorParts[0]}`;
			} else {
				const parts = authorsRaw[0].split(", ");
				authorsFormatted = `${parts[1]} ${parts[0]}`;
			}

			// Initialize citation string with authors
			let citation = `${authorsFormatted}`;

			// Check and format the date
			const dateField = entry.getField("DATE");
			if (dateField) {
				const year = new Date(bibtex.normalizeFieldValue(dateField)).getFullYear();
				citation += `. ${year}`;
			} else {
				console.warn("Date field is missing for the citation.");
				citation += ". [Date missing]";
			}

			// Check and format the title
			const titleField = entry.getField("TITLE");
			if (titleField) {
				const title = bibtex.normalizeFieldValue(titleField);
				citation += `. "${title}"`;
			} else {
				console.warn("Title field is missing for the citation.");
				citation += ". [Title missing]";
			}

			// Check and format the identifier (eprint, issn, doi)
			const identifier = getFirstAvailableIdentifier(entry, ["EPRINT", "ISSN", "DOI"]);
			if (identifier) {
				citation += ` ${identifier}`;
			} else {
				console.warn("Identifier (eprint, issn, doi) is missing for the citation.");
				citation += " [Identifier missing]";
			}

			// Finish constructing the citation
			return citation + ".";
		}

		function extractDataFromField(field) {
			if (!field) return '';

			if (field.type === 'bracedstringwrapper' || field.type === 'bracedstring') {
				return field.data.map(subField => {
					if (typeof subField === 'object') {
						return extractDataFromField(subField); // Recursively process nested objects
					} else {
						return subField; // Directly use the string or number
					}
				}).join('');
			} else if (Array.isArray(field)) {
				return field.map(subField => extractDataFromField(subField)).join('');
			} else {
				return field.toString();
			}
		}

		function getFirstAvailableIdentifier(entry, fields) {
			for (const field of fields) {
				const value = entry.getField(field);
				if (value) {
					const identifier = extractDataFromField(value);
					if (identifier) {
						switch (field) {
							case "EPRINT":
								return `arXiv:${identifier}`;
							case "ISSN":
								return `ISSN:${identifier}`;
							case "DOI":
								return `DOI:${identifier}`;
							default:
								return identifier; // Default case if new types are added later
						}
					}
				}
			}
			return null;
		}

		function getNonBibCitation(entry) {
			let citationParts = [];

			// Extract and format the title if available
			const titleField = entry.getField("TITLE");
			if (titleField) {
				const title = bibtex.normalizeFieldValue(titleField);
				citationParts.push(`"${title}"`);
			}

			// Extract and format the URL if available, and use the domain name as 'author'
			const urlField = entry.getField("URL");
			if (urlField) {
				const url = bibtex.normalizeFieldValue(urlField);
				const urlObject = new URL(url);
				const domainName = urlObject.hostname.replace('www.', ''); // Remove 'www.' if present
				citationParts.unshift(domainName); // Add as the first element
				citationParts.push(url);
			}

			// Extract and format the URL date if available
			const urldateField = entry.getField("URLDATE");
			if (urldateField) {
				const urldate = bibtex.normalizeFieldValue(urldateField);
				citationParts.push(`accessed on ${urldate}`);
			}

			// Join all parts with commas and return the full citation, if there are parts
			if (citationParts.length > 0) {
				return citationParts.join(", ") + ".";
			} else {
				// Return an empty string if no relevant information could be formatted
				return "";
			}
		}
	</script>
	<script>
		// Lottie animations
		Reveal.on('slidechanged', function (event) {
			if (event.currentSlide.id === 'method-slide-2') {
				loadLottieAnimations();
			}
		});

		function loadLottieAnimations() {
			const animations = [
				// { id: 'overall-value', path: './src/anim/abacus.json', colorNms: { 'Highlight': '#B75D69' } },
				{ id: 'overall-value', path: './src/anim/abacus.json', colorNms: {} },
				{ id: 'points-nfl', path: './src/anim/points_nfl.json', colorNms: {} },
				{ id: 'points-nba', path: './src/anim/points_nba.json', colorNms: {} },
				{ id: 'batting-mlb', path: './src/anim/batting_mlb.json', colorNms: {} },
				{ id: 'points-nhl', path: './src/anim/goal_nhl.json', colorNms: {} },
				{ id: 'goals-mls', path: './src/anim/goals_mls.json', colorNms: {} },
				{ id: 'tackles-nfl', path: './src/anim/tackles_nfl.json', colorNms: {} },
				{ id: 'blocks-nba', path: './src/anim/blocks_nba.json', colorNms: {} },
				{ id: 'era-mlb', path: './src/anim/era_mlb.json', colorNms: {} },
				{ id: 'hits-nhl', path: './src/anim/hit_nhl.json', colorNms: {} },
				{ id: 'tackles-won-mls', path: './src/anim/tackles_mls.json', colorNms: {} },
				{ id: 'height-all', path: './src/anim/height.json', colorNms: {} },
				{ id: 'weight-all', path: './src/anim/weight.json', colorNms: {} },
				{ id: 'language-difficulty-all', path: './src/anim/languages.json', colorNms: {} },
				{ id: 'travel-distance-all', path: './src/anim/distance.json', colorNms: {} },
			];

			animations.forEach(anim => {
				const element = document.getElementById(anim.id);
				if (!element) {
					console.warn("Could not find element", element, "for id", anim.id)
				}
				if (element && !element.classList.contains('lottie-loaded')) {
					fetch(anim.path)
						.then(response => response.json())
						.then(data => {
							// Loop through each layer and modify colors
							data.layers.forEach(layer => {
								modifyColors(layer, anim.colorNms, anim.id); // Pass the color names and their new values
							});
							lottie.loadAnimation({
								container: element,
								renderer: 'svg',
								loop: true,
								autoplay: true,
								animationData: data
							});
							element.classList.add('lottie-loaded');
						});
				}
			});
		}


		function hexToRgba(hex) {
			// Expand shorthand form (e.g. "03F") to full form (e.g. "0033FF")
			let r = 0, g = 0, b = 0, a = 1;
			if (hex.length == 4) {
				r = parseInt(hex[1] + hex[1], 16);
				g = parseInt(hex[2] + hex[2], 16);
				b = parseInt(hex[3] + hex[3], 16);
			} else if (hex.length == 7) {
				r = parseInt(hex[1] + hex[2], 16);
				g = parseInt(hex[3] + hex[4], 16);
				b = parseInt(hex[5] + hex[6], 16);
			} else if (hex.length == 9) { // Handling hex with alpha
				r = parseInt(hex[1] + hex[2], 16);
				g = parseInt(hex[3] + hex[4], 16);
				b = parseInt(hex[5] + hex[6], 16);
				a = parseInt(hex[7] + hex[8], 16) / 255;
			}
			return [r / 255, g / 255, b / 255, a]; // Normalize RGB values to [0, 1] range
		}

		function modifyColors(layer, colorMapping, animId) {
			if (!layer.ef) return; // If no effects field, exit the function

			layer.ef.forEach(effect => {
				// Check if effect is a color control and its name is in the mapping
				if (effect.nm && colorMapping[effect.nm] && effect.ef) {
					effect.ef.forEach(subEffect => {
						if (subEffect.ty === 2 && subEffect.v) { // Ensure it's a color type effect
							subEffect.v.k = hexToRgba(colorMapping[effect.nm]);
							console.log("Changed color for", animId, "with effect", effect.nm, "to", colorMapping[effect.nm])
						}
					});
				}

				// If the effect itself has nested effects, recurse into them
				if (effect.ef) {
					effect.ef.forEach(innerEffect => {
						modifyColors(innerEffect, colorMapping, animId); // Recursive call
					});
				}
			});
		}

	</script>

	<script>
		// Gauges
		document.addEventListener('DOMContentLoaded', function () {
			// Function to create a gauge
			function createGauge(containerId, radius) {
				const strokeWidth = radius * 0.2;
				const innerRadius = radius - strokeWidth;
				const circumference = innerRadius * 2 * Math.PI;
				const arc = circumference * 0.9;
				const dashArray = `${arc} ${circumference}`;
				const transform = `rotate(108 ${radius} ${radius})`;

				const svgNS = "http://www.w3.org/2000/svg";
				const svg = document.createElementNS(svgNS, "svg");
				svg.setAttribute("width", radius * 2);
				svg.setAttribute("height", radius * 2);
				svg.setAttribute("class", "gauge");

				const gradient = document.createElementNS(svgNS, "defs");
				const linearGradient = document.createElementNS(svgNS, "linearGradient");
				linearGradient.setAttribute("id", `grad${containerId}`);
				linearGradient.setAttribute("x1", "0%");
				linearGradient.setAttribute("y1", "0%");
				linearGradient.setAttribute("x2", "100%");
				linearGradient.setAttribute("y2", "100%");
				const stop1 = document.createElementNS(svgNS, "stop");
				stop1.setAttribute("offset", "0%");
				stop1.setAttribute("stop-color", "#B75D69");
				const stop2 = document.createElementNS(svgNS, "stop");
				stop2.setAttribute("offset", "100%");
				stop2.setAttribute("stop-color", "#edc79b");
				linearGradient.appendChild(stop1);
				linearGradient.appendChild(stop2);
				gradient.appendChild(linearGradient);
				svg.appendChild(gradient);

				const circleBase = document.createElementNS(svgNS, "circle");
				circleBase.setAttribute("class", "gauge_base");
				circleBase.setAttribute("cx", radius);
				circleBase.setAttribute("cy", radius);
				circleBase.setAttribute("r", innerRadius);
				circleBase.setAttribute("fill", "transparent");
				circleBase.setAttribute("stroke", "gray");
				circleBase.setAttribute("stroke-dasharray", dashArray);
				circleBase.setAttribute("stroke-linecap", "round");
				circleBase.setAttribute("stroke-width", strokeWidth);
				circleBase.setAttribute("transform", transform);
				svg.appendChild(circleBase);

				const circlePercent = document.createElementNS(svgNS, "circle");
				circlePercent.setAttribute("class", "gauge_percent");
				circlePercent.setAttribute("cx", radius);
				circlePercent.setAttribute("cy", radius);
				circlePercent.setAttribute("r", innerRadius);
				circlePercent.setAttribute("fill", "transparent");
				circlePercent.setAttribute("stroke", `url(#grad${containerId})`);
				circlePercent.setAttribute("stroke-dasharray", dashArray);
				circlePercent.setAttribute("stroke-dashoffset", arc);
				circlePercent.setAttribute("stroke-linecap", "round");
				circlePercent.setAttribute("stroke-width", strokeWidth);
				circlePercent.setAttribute("transform", transform);
				svg.appendChild(circlePercent);

				const text = document.createElementNS(svgNS, "text");
				text.setAttribute("x", radius);
				text.setAttribute("y", radius + radius * 0.15);
				text.setAttribute("class", "gauge_text");
				text.setAttribute("font-size", radius * 0.7);
				text.textContent = "0";
				svg.appendChild(text);

				document.getElementById(containerId).appendChild(svg);
				return { circle: circlePercent, text: text };
			}

			// Initialize gauges after Reveal is ready
			Reveal.on('ready', function (event) {
				const gauges = [];
				gauges.push(createGauge("gaugeContainer1", 45));
				gauges.push(createGauge("gaugeContainer2", 45));
				gauges.push(createGauge("gaugeContainer3", 45));
				gauges.push(createGauge("gaugeContainer4", 45));
				gauges.push(createGauge("gaugeContainer5", 45));
				gauges.push(createGauge("gaugeContainer6", 45));
				gauges.push(createGauge("gaugeContainer7", 45));
				gauges.push(createGauge("gaugeContainer8", 45));
				gauges.push(createGauge("gaugeContainer9", 45));
				gauges.push(createGauge("gaugeContainer10", 45));
				gauges.push(createGauge("gaugeContainer11", 45));
				gauges.push(createGauge("gaugeContainer12", 45));
				gauges.push(createGauge("gaugeContainer13", 45));
				gauges.push(createGauge("gaugeContainer14", 45));
				gauges.push(createGauge("gaugeContainer15", 45));

				function animateGauge(gauge, percent) {
					const circumference = parseFloat(gauge.circle.getAttribute("stroke-dasharray").split(' ')[0]);
					const offset = circumference - (percent / 100) * (circumference * 1);
					gauge.circle.style.transition = 'stroke-dashoffset 2s ease-out';
					gauge.circle.style.strokeDashoffset = offset.toString();

					let start = 0;
					const step = (timestamp) => {
						if (!start) start = timestamp;
						const elapsed = timestamp - start;
						const currentPercent = Math.min(elapsed / 2000 * percent, percent);
						gauge.text.textContent = `${currentPercent.toFixed(1)}`;
						if (currentPercent < percent) {
							window.requestAnimationFrame(step);
						}
					};
					window.requestAnimationFrame(step);
				}

				// Listen for slide changes to animate gauges
				Reveal.on('slidechanged', function (event) {
					if (event.currentSlide.id == 'podium-slide-1') {
						animateGauge(gauges[0], 61.3);
						animateGauge(gauges[1], 49.3);
						animateGauge(gauges[2], 66.9);
						animateGauge(gauges[3], 99.0);
						animateGauge(gauges[4], 85.9);
					}
					else if (event.currentSlide.id == 'podium-slide-2') {
						animateGauge(gauges[5], 69.0);
						animateGauge(gauges[6], 68.8);
						animateGauge(gauges[7], 67.2);
						animateGauge(gauges[8], 75.4);
						animateGauge(gauges[9], 85.9);
					}
					else if (event.currentSlide.id == 'podium-slide-3') {
						animateGauge(gauges[10], 88.7);
						animateGauge(gauges[11], 58.6);
						animateGauge(gauges[12], 61.2);
						animateGauge(gauges[13], 89.2);
						animateGauge(gauges[14], 100.0);
					}
				});
			});
		});

	</script>

	<script>
		// Gapminder animation
		Reveal.on('ready', function (event) {
			d3.csv('./src/data/data_seasons.csv').then(function (data) {
				var lookup = {};

				function getData(season, continent) {
					var bySeason = lookup[season] || (lookup[season] = {});
					var trace = bySeason[continent] || (bySeason[continent] = {
						x: [],
						y: [],
						id: [],
						text: [],
						marker: { size: [] }
					});
					return trace;
				}

				// Process each row
				data.forEach(function (datum) {
					var season = datum.Season;
					var continent = datum['Home Continent'];
					var trace = getData(season, continent);

					trace.text.push(datum.Player);
					trace.id.push(datum.Player);
					trace.x.push(+datum['Defensive Performance']);
					trace.y.push(+datum['Offensive Performance']);
					trace.marker.size.push(500);  // Example size, adjust as necessary
				});

				// Ensure we have seasons and continents populated
				var seasons = Object.keys(lookup);
				if (seasons.length === 0) {
					console.error('No data available for seasons');
					return;
				}

				// Gather all continents across all seasons
				var allContinents = new Set();
				seasons.forEach(season => {
					Object.keys(lookup[season]).forEach(continent => {
						allContinents.add(continent);
					});
				});
				allContinents = Array.from(allContinents); // Convert Set to Array for easier processing

				var firstSeason = lookup[seasons[0]];

				// Create the main traces, one for each continent
				var traces = allContinents.map(function (continent) {
					var data = firstSeason[continent] || { x: [], y: [], id: [], text: [], marker: { size: [] } };
					return {
						name: continent,
						x: data.x.slice(),
						y: data.y.slice(),
						id: data.id.slice(),
						text: data.text.slice(),
						mode: 'markers',
						marker: {
							size: data.marker.size,
							sizemode: 'area',
							sizeref: 2,
						}
					};
				});

				// Create a frame for each season
				var frames = [];
				seasons.forEach(function (season) {
					frames.push({
						name: season,
						data: allContinents.map(function (continent) {
							var data = lookup[season][continent] || { x: [], y: [], id: [], text: [], marker: { size: [] } };
							return {
								name: continent,
								x: data.x.slice(),
								y: data.y.slice(),
								id: data.id.slice(),
								text: data.text.slice(),
								mode: 'markers',
								marker: {
									size: data.marker.size,
									sizemode: 'area',
									sizeref: 2
								}
							};
						})
					});
				});

				// Slider steps for each season
				var sliderSteps = seasons.map(function (season) {
					return {
						method: 'animate',
						label: season,
						args: [[season], {
							mode: 'immediate',
							transition: { duration: 300 },
							frame: { duration: 300, redraw: true }
						}]
					};
				});

				var layout = {
					xaxis: {
						title: 'Defensive Performance',
						range: [0, 100]  // Adjust according to the actual data range
					},
					yaxis: {
						title: 'Offensive Performance',
						range: [0, 100]  // Adjust according to the actual data range
					},
					hovermode: 'closest',
					updatemenus: [{
						x: 0,
						y: 0,
						yanchor: 'top',
						xanchor: 'left',
						showactive: false,
						direction: 'left',
						type: 'buttons',
						pad: { t: 87, r: 10 },
						buttons: [{
							method: 'animate',
							args: [null, {
								mode: 'immediate',
								fromcurrent: true,
								transition: { duration: 300 },
								frame: { duration: 500, redraw: true }
							}],
							label: 'Play'
						}, {
							method: 'animate',
							args: [[null], {
								mode: 'immediate',
								transition: { duration: 0 },
								frame: { duration: 0, redraw: false }
							}],
							label: 'Pause'
						}]
					}],
					sliders: [{
						pad: { l: 130, t: 55 },
						currentvalue: {
							visible: true,
							prefix: 'Season:',
							xanchor: 'right',
							font: { size: 20, color: '#666' }
						},
						steps: sliderSteps
					}]
				};

				// Create the plot
				Plotly.newPlot('myDiv', {
					data: traces,
					layout: layout,
					frames: frames,
				});

			}).catch(function (error) {
				console.error('Error loading CSV:', error);
			});
		});


	</script>

</body>

</html>